// Code generated by go-swagger; DO NOT EDIT.

//
// Copyright NetFoundry Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// __          __              _
// \ \        / /             (_)
//  \ \  /\  / /_ _ _ __ _ __  _ _ __   __ _
//   \ \/  \/ / _` | '__| '_ \| | '_ \ / _` |
//    \  /\  / (_| | |  | | | | | | | | (_| | : This file is generated, do not edit it.
//     \/  \/ \__,_|_|  |_| |_|_|_| |_|\__, |
//                                      __/ |
//                                     |___/

package rest_model

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Interface A resource describing a network interface
//
// swagger:model interface
type Interface struct {

	// addresses
	// Required: true
	Addresses []string `json:"addresses"`

	// hardware address
	// Required: true
	HardwareAddress *string `json:"hardwareAddress"`

	// index
	// Required: true
	// Minimum: 0
	Index *int64 `json:"index"`

	// is broadcast
	// Required: true
	IsBroadcast *bool `json:"isBroadcast"`

	// is loopback
	// Required: true
	IsLoopback *bool `json:"isLoopback"`

	// is multicast
	// Required: true
	IsMulticast *bool `json:"isMulticast"`

	// is running
	// Required: true
	IsRunning *bool `json:"isRunning"`

	// is up
	// Required: true
	IsUp *bool `json:"isUp"`

	// mtu
	// Required: true
	// Minimum: 0
	Mtu *int64 `json:"mtu"`

	// name
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this interface
func (m *Interface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddresses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHardwareAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsBroadcast(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsLoopback(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsMulticast(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsRunning(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsUp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMtu(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Interface) validateAddresses(formats strfmt.Registry) error {

	if err := validate.Required("addresses", "body", m.Addresses); err != nil {
		return err
	}

	return nil
}

func (m *Interface) validateHardwareAddress(formats strfmt.Registry) error {

	if err := validate.Required("hardwareAddress", "body", m.HardwareAddress); err != nil {
		return err
	}

	return nil
}

func (m *Interface) validateIndex(formats strfmt.Registry) error {

	if err := validate.Required("index", "body", m.Index); err != nil {
		return err
	}

	if err := validate.MinimumInt("index", "body", *m.Index, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Interface) validateIsBroadcast(formats strfmt.Registry) error {

	if err := validate.Required("isBroadcast", "body", m.IsBroadcast); err != nil {
		return err
	}

	return nil
}

func (m *Interface) validateIsLoopback(formats strfmt.Registry) error {

	if err := validate.Required("isLoopback", "body", m.IsLoopback); err != nil {
		return err
	}

	return nil
}

func (m *Interface) validateIsMulticast(formats strfmt.Registry) error {

	if err := validate.Required("isMulticast", "body", m.IsMulticast); err != nil {
		return err
	}

	return nil
}

func (m *Interface) validateIsRunning(formats strfmt.Registry) error {

	if err := validate.Required("isRunning", "body", m.IsRunning); err != nil {
		return err
	}

	return nil
}

func (m *Interface) validateIsUp(formats strfmt.Registry) error {

	if err := validate.Required("isUp", "body", m.IsUp); err != nil {
		return err
	}

	return nil
}

func (m *Interface) validateMtu(formats strfmt.Registry) error {

	if err := validate.Required("mtu", "body", m.Mtu); err != nil {
		return err
	}

	if err := validate.MinimumInt("mtu", "body", *m.Mtu, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Interface) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this interface based on context it is used
func (m *Interface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *Interface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Interface) UnmarshalBinary(b []byte) error {
	var res Interface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
